import os, os.path, commands, platform
import distutils.sysconfig

version = "0.6"

#----------------------------------------------------
# CREATE ENVIRONMENT, LOAD TOOLS, SOME DEFAULT PATHS

can_install=True

# Should exist in path
cppunit_config_command = 'cppunit-config --libs --cflags'

if os.environ.has_key('OSTYPE') and os.environ['OSTYPE']=='msys':
	env = Environment(ENV=os.environ
		, tools = ['mingw','swig','disttar']
		, toolpath = ['scons']
	)
	cppunit_config_command = 'sh cppunit-config --libs --cflags'
else:
	env = Environment(ENV=os.environ
		, tools = ['default','swig','disttar']
		, toolpath = ['scons']
	)

	if platform.system()=="Windows":
		if env.has_key('MSVS'):
			# for exception handling, following errmsg from VC6
			env.Append(CXXFLAGS=['/EHsc'])
			env.Append(CPPDEFINES='UNITS_CAST_THROW');
			print "VISUAL C++ detected... (Version",env['MSVS']['VERSION']+")"
		else:
			print "WARNING: non-POSIX tools"
		env.AppendUnique(CPPPATH=[os.environ['INCLUDE'].split(";")])
		can_install=False
	
if platform.system()=="Windows":
	default_emso_location = "c:\\Program Files\\EMSO\\interface"
	default_prefix = 'c:/MinGW'
else:
	default_emso_location = None
	default_prefix = '/usr/local'

if not default_emso_location or not os.path.exists(default_emso_location):
	default_emso_location=False

# Find 'ascend-config' script, if available
if platform.system()=='Windows':
	default_ascend_config="C:\\Program Files\\ASCEND\\ascend-config.bat"
	if not os.path.exists(default_ascend_config):
		default_ascend_config=None

else:
	try:
		import subprocess
		default_ascend_config = \
			subprocess.Popen(
				['which','ascend-config']
				,stdout=subprocess.PIPE
				,stderr=subprocess.PIPE
			).communicate()[0].strip()
	except Exception, e:
		print "FAILED TO DETECT 'ascend-config' IN PATH (%s)" % e
		default_ascend_config = None

#------------------------------------------------------
# OPTIONS

opts = Options(['options.cache', 'config.py'])

opts.Add(PackageOption(
	'EMSO_INCDIR',"Location of EMSO 'interface' directory", default_emso_location
))
opts.Add(BoolOption(
	'HAVE_EMSO',"Build EMSO hook libraries", False
))

if can_install:
	opts.Add(PathOption(
		'INSTALL_PREFIX'
		,"Base directory for install, see also INSTALL_LIB and INSTALL_INCLUDE"
		,default_prefix
	))

	opts.Add(PathOption(
		'LIBDIR',"Location to install library", "$INSTALL_PREFIX/lib"
	))
	opts.Add(PathOption(
		'INCDIR',"Location to install headers", "$INSTALL_PREFIX/include"
	))

	opts.Add(PathOption(
		'INSTALL_ROOT'
		,"Root onto which installation should take place. Normally only for "
			+"use when building RPMs"
		,None
	))

opts.Add(BoolOption(
	'ENABLE_SAT_P'
	, "Enable saturation curves in terms of pressure"+
		"(introduces some numerical problems in iterative cases if"+
		"you're not careful)"
	, True
))

opts.Add(BoolOption(
	'ENABLE_DEBUG_FLAG',"Add debug symbols to object code, for use with gdb etc", False
))

opts.Add(BoolOption(
	'WITH_CTESTS'
	,"Perform compile-time testing of the units of measurement code"
	,True
))

opts.Add(PathOption(
	'ASCEND_CONFIG'
	,"Location of the 'ascend-config' script"
	,default_ascend_config
))

opts.Add(PathOption(
	'ASCEND_SRCROOT'
	,"Location of top-level ASCEND source directory. Use this if ASCEND is not"
		+"actually installed on your system (eg you are testing/developing)."
	,None
))

opts.Add(
	'DISTTAR_NAME'
	,"Stem name of the tarball created by 'scons dist'."
	,"freesteam-"+version
)

opts.Update(env)

opts.Save('options.cache',env)

Help(opts.GenerateHelpText(env))

#-------------
# Apply the options to the environment

if env['ENABLE_SAT_P']:
	env.Append(CPPDEFINES=['ENABLE_SAT_P'])

if env['ENABLE_DEBUG_FLAG']:
	env.Append(CXXFLAGS=['-g'])
	env.Append(CFLAGS=['-g'])

#------------------------------------------------------
# CONFIGURATION TESTS

#-----------
# ISNAN DETECTION

#- - - 8< - - -
checknansrc = """// Test for 'isnan'
#include <cmath>
#include <stdexcept>
#include <iostream>
using namespace std;

int main(void){
	int x= isnan(1);
	return 0;
}
#ifdef __MINGW32__
# error "MINGW32 isnan is no good for our purpose"
#endif

"""
#- - - 8< - - -

def CheckIsNan(context):
	context.Message( 'Checking for isnan...' )
	lastLIBS = context.env.get('LIBS')
	lastCPPFLAGS = context.env.get('CPPFLAGS')
	context.env.Append(LIBS = ['m'])
	tuple = context.TryRun(checknansrc,'.cpp')
	#print tuple
	if not tuple[0]:
		context.env.Replace(
			LIBS = lastLIBS
			, CPPFLAGS = lastCPPFLAGS
		)
		context.config_h = context.config_h +  "#undef HAVE_ISNAN\n"
	else:
		context.config_h = context.config_h +  "#define HAVE_ISNAN\n"

	context.Result(tuple[0])
	return tuple[0]

def CheckCppUnitConfig(context):
	context.Message( 'Checking cppunit-config...' )
	lastLIBS = context.env.get('LIBS')
	lastCPPFLAGS = context.env.get('CPPFLAGS')

#	for k in conf.env['ENV']:
#		print "ENV:",k,"=",env['ENV'][k]

	try:
		context.env.ParseConfig(cppunit_config_command)
	except IOError:
		context.env.Replace(
			LIBS = lastLIBS
			, CPPFLAGS = lastCPPFLAGS
		)
		context.Result(0)
		return 0
	except:
		context.env.Replace(
			LIBS = lastLIBS
			, CPPFLAGS = lastCPPFLAGS
		)
		context.Result(0)
		return 0
		
	context.config_h = context.config_h + "#define HAVE_CPPUNIT_CONFIG\n"
	context.Result(1)
	return 1

#----------------
# SWIG

import os,re

need_fortran = False

def get_swig_version(env):
	cmd = env['SWIG']+' -version'
	(cin,coutcerr) = os.popen4(cmd)
	output = coutcerr.read()
	
	restr = "SWIG\\s+Version\\s+(?P<maj>[0-9]+)\\.(?P<min>[0-9]+)\\.(?P<pat>[0-9]+)\\s*$"
	expr = re.compile(restr,re.M);
	m = expr.search(output);
	if not m:
		return None
	maj = int(m.group('maj'))
	min = int(m.group('min'))
	pat = int(m.group('pat'))

	return (maj,min,pat)
	

def CheckSwigVersion(context):
	
	try:
		context.Message("Checking version of SWIG... ")
		maj,min,pat = get_swig_version(context.env)
	except:
		context.Result("Failed to detect version, or failed to run SWIG")
		return 0;
	
	if maj == 1 and (
			min > 3
			or (min == 3 and pat >= 24)
		):
		context.Result("ok, %d.%d.%d" % (maj,min,pat))
		return 1;
	else:
		context.Result("too old, %d.%d.%d" % (maj,min,pat))
		return 0;

#------------------------------------------------------
# CONFIGURATION


conf = Configure(env
	, custom_tests = { 
		'CheckIsNan' : CheckIsNan
		,'CheckCppUnitConfig' : CheckCppUnitConfig
		,'CheckSwigVersion' : CheckSwigVersion
	} 
	, config_h = "config.h"
)

# Math library...

if not conf.CheckLibWithHeader(['m','c'], 'math.h', 'C'):
	print 'Did not find libm.a or m.lib, exiting!'
	Exit(1)

# IsNan

conf.CheckIsNan()
# CppUnit...

have_cppunit = False

if conf.CheckCppUnitConfig():
	if conf.CheckLibWithHeader("cppunit","cppunit/TestCase.h","C++"):
		#print "CPPUNIT OK!"
		have_cppunit=True

# Python DEV files

env['HAVE_PYTHON'] = False
_havepy = conf.CheckHeader(distutils.sysconfig.get_python_inc()+"/Python.h")
if _havepy:
	env['HAVE_PYTHON'] = True

# Swig

env['HAVE_SWIG'] = False
_swigv = conf.CheckSwigVersion()
if _swigv:
	env['HAVE_SWIG'] = True

env = conf.Finish()

#------------------------------------------------------
# BUILD THE STATIC LIBRARY -- easy :-)


list = Split("""
	exception.cpp steamcalculator.cpp state.cpp region1.cpp region2.cpp 
	region3.cpp region4.cpp boundaries.cpp steamcalculatorexception.cpp zeroin.cpp 
	designbycontract.cpp units.cpp solver.cpp steamproperty.cpp satcurve.cpp b23curve.cpp 
	b13curve.cpp convergencetest.cpp solver2.cpp iapws95.cpp measurement.cpp
""")

lib = env.Library('freesteam',list)

examplesrc = Split("example.cpp")

env.Program('example.cpp'
	, LIBS = ['freesteam']
	, LIBPATH='.'
)


#env.Program('testnan',['testnan.cpp']
#	, LIBS = 'm'
#	, CPPFLAGS = '-fsignaling-nans'
#)

#------------------------------------------------------
# SUBDIRECTORIES....

# Testing with CppUnit...

if have_cppunit:
	env.SConscript(['test/SConscript'],'env have_cppunit') #, 'cli/SConscript'
else:
	print "Skipping... Tests (no CppUnit found)"

# Compile-time C++ template testing

if env['WITH_CTESTS']:
	env.SConscript(['ctest/SConscript'],'env')

# Command-line-interface programs

env.SConscript(['cli/SConscript'],'env')

# EMSO hooks

if env['HAVE_EMSO']:
	env.SConscript(['emso/SConscript'],'env')
else:
	print "Skipping... EMSO hook libraries"

# Python hooks

install_python = []
install_python.append( env.SConscript(['python/SConscript'],'env') )

# ASCEND hooks

install_ascend = []
install_ascend.append( env.SConscript(['ascend/SConscript'],'env') )

#------------------------------------------------------
# Recipe for 'CHMOD' ACTION 	 
  	 
import SCons 	 
from SCons.Script.SConscript import SConsEnvironment 	 
SConsEnvironment.Chmod = SCons.Action.ActionFactory(os.chmod, 	 
	lambda dest, mode: 'Chmod("%s", 0%o)' % (dest, mode)) 	 
  	 
def InstallPerm(env, dest, files, perm): 	 
	obj = env.Install(dest, files) 	 
	for i in obj: 	 
		env.AddPostAction(i, env.Chmod(str(i), perm))
	return dest
  	 
SConsEnvironment.InstallPerm = InstallPerm

# define wrappers 	 
SConsEnvironment.InstallProgram = lambda env, dest, files: InstallPerm(env, dest, files, 0755) 	 
SConsEnvironment.InstallHeader = lambda env, dest, files: InstallPerm(env, dest, files, 0644) 	 
SConsEnvironment.InstallLibrary = lambda env, dest, files: InstallPerm(env, dest, files, 0644) 	 

#------------------------------------------------------
# INSTALLATION

try:
	umask = os.umask(022)
except OSError:
	# ignore on systems that don't support umask
	pass

if can_install:
	install_lib = env.InstallLibrary("$LIBDIR", [lib])

	import glob
	files = glob.glob("*.h")

	if env.get('HAVE_SWIG') and env.get('HAVE_PYTHON'):
		files += glob.glob("*.i")

	#print files

	install_inc = env.InstallHeader("$INCDIR/freesteam", files)
		
	env.Alias('install',[install_lib, install_inc]+install_ascend+install_python)

	
#--------------------------------------------------------
# DISTRIBUTION TARBALL

env['DISTTAR_FORMAT']='bz2'
env.Append(
	DISTTAR_EXCLUDEEXTS=['.o','.os','.so','.a','.dll','.cc','.cache','.pyc','.cvsignore','.dblite','.log','.pl']
	, DISTTAR_EXCLUDEDIRS=['CVS','.svn','.sconf_temp', 'dist']
)

tar = env.DistTar("dist/"+env['DISTTAR_NAME']
	, [env.Dir('#')]
)

#--------------------------------------------------------
# DEFAULT TARGETS

default_targets = ['example']
if env.get('HAVE_PYTHON') and env.get('HAVE_SWIG'):
	default_targets.append('python')

print "Building targets: %s" % " ".join(default_targets)
env.Default(default_targets)

