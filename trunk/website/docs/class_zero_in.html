<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>freesteam: ZeroIn&lt; Subject, Ordinate, Abscissa &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ZeroIn&lt; Subject, Ordinate, Abscissa &gt; Class Template Reference</h1>Root-finding by Brent algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="zeroin_8h-source.html">zeroin.h</a>&gt;</code>
<p>
<p>Inheritance diagram for ZeroIn&lt; Subject, Ordinate, Abscissa &gt;:
<p><center><img src="class_zero_in.png" usemap="#ZeroIn< Subject, Ordinate, Abscissa >_map" border="0" alt=""></center>
<map name="ZeroIn< Subject, Ordinate, Abscissa >_map">
<area href="class_design_by_contract.html" alt="DesignByContract" shape="rect" coords="0,0,234,24">
</map>
<a href="class_zero_in-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a1" doxytag="ZeroIn::setLowerBound" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a1">setLowerBound</a> (const Abscissa &amp;ax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the lower bound of the range that will be searched for a solution. <br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a2" doxytag="ZeroIn::getLowerBound" ></a>
Abscissa&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a2">getLowerBound</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setLowerBound <br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a3" doxytag="ZeroIn::setUpperBound" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a3">setUpperBound</a> (const Abscissa &amp;bx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the upper bound of the range that will be searched for a solution. <br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a4" doxytag="ZeroIn::getUpperBound" ></a>
Abscissa&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a4">getUpperBound</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setUpperBound <br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a5" doxytag="ZeroIn::setTolerance" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a5">setTolerance</a> (const Abscissa &amp;tol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set tolerance of the solution <br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a6">setMethod</a> (Ordinate(Subject::*method)(const Abscissa &amp;))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the member function that will be solved.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="class_zero_in.html#a7">visit</a> (Subject *subject)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ZeroIn visit method.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a8" doxytag="ZeroIn::isSolved" ></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>isSolved</b> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a9" doxytag="ZeroIn::isSolved" ></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>isSolved</b> (const Ordinate &amp;error)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a10" doxytag="ZeroIn::getSolution" ></a>
Abscissa&nbsp;</td><td class="memItemRight" valign=bottom><b>getSolution</b> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a11" doxytag="ZeroIn::getError" ></a>
Ordinate&nbsp;</td><td class="memItemRight" valign=bottom><b>getError</b> (void) const</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class Subject, class Ordinate = double, class Abscissa = double&gt;<br>
 class ZeroIn&lt; Subject, Ordinate, Abscissa &gt;</h3>

Root-finding by Brent algorithm. 
<p>
Whacko, this class does root finding with units intact!<p>
We will be varying the x (Abscissa) value until the y (Ordinate) value is zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>Subject</em>&nbsp;</td><td>class on which solving of a function like y(x)=0 is to be done </td></tr>
    <tr><td></td><td valign=top><em>Ordinate</em>&nbsp;</td><td>y-value type </td></tr>
    <tr><td></td><td valign=top><em>Abscissa</em>&nbsp;</td><td>x-value type</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="units_8h.html">units.h</a> <p>
<a class="el" href="class_zero_in.html#a7">ZeroIn::visit</a></dd></dl>
To solve the quadratic x²-4x-4=0 in the region x in [-10,4.566] by iteration (<dl compact><dt><b>See also:</b></dt><dd>zeroin.test.cpp):</dd></dl>
<div class="fragment"><pre>                        <span class="keyword">class </span>Quad{
                                <span class="keywordtype">double</span> eval(<span class="keywordtype">double</span> x){
                                        <span class="keywordflow">return</span> x*x-4*x-4;
                                }
                        };

                        <span class="comment">// ...</span>

                        Quad q;

                        <a class="code" href="class_zero_in.html">ZeroIn&lt;Quad&gt;</a> z;
                        z.<a class="code" href="class_zero_in.html#a1">setLowerBound</a>(-10);
                        z.<a class="code" href="class_zero_in.html#a3">setUpperBound</a>(4.566);
                        z.<a class="code" href="class_zero_in.html#a6">setMethod</a>(&amp;ZeroInTest::eval);
                        z.<a class="code" href="class_zero_in.html#a5">setTolerance</a>(1e-10);
                        z.<a class="code" href="class_zero_in.html#a7">visit</a>(q);

                        <span class="keywordflow">if</span>(z.<a class="code" href="class_zero_in.html#a8">isSolved</a>(0.001)){
                                cerr &lt;&lt; <span class="stringliteral">"Quadratic was solved, x = "</span> &lt;&lt; z.<a class="code" href="class_zero_in.html#a10">getSolution</a>() &lt;&lt; endl;
                        }

                        cerr &lt;&lt; <span class="stringliteral">"Unable to solve quadratic over given region"</span> &lt;&lt; endl;
</pre></div>
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a6" doxytag="ZeroIn::setMethod" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Subject, class Ordinate = double, class Abscissa = double&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="class_zero_in.html">ZeroIn</a>&lt; Subject, Ordinate, Abscissa &gt;::setMethod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Ordinate(Subject::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>method</em>)(const Abscissa &amp;)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the member function that will be solved. 
<p>
The method Ordinate(Subject::*method)(Abscissa) returns values like y(x)<p>
<div class="fragment"><pre>                                z-&gt;<a class="code" href="class_zero_in.html#a6">setMethod</a>(&amp;Quadratic::evaluate);
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="ZeroIn::visit" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Subject, class Ordinate = double, class Abscissa = double&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="class_zero_in.html">ZeroIn</a>&lt; Subject, Ordinate, Abscissa &gt;::visit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Subject *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>subject</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ZeroIn visit method. 
<p>
This is a visitor pattern implementation of the Brent ZEROIN routine adapted from the C math library version.<p>
USAGE<p>
<dl compact><dt><b>See also:</b></dt><dd>brent.shar at <a href="http://www.netlib.org/c/">http://www.netlib.org/c/</a></dd></dl>
Original documentation:<p>
function ZEROIN - obtain a function zero within the given range<p>
Input double zeroin(ax,bx,f,tol) double ax; Root will be sought for within a range [ax,bx] double bx;<p>
double (*f)(double x); Name of the function whose zero will be sought for<p>
double tol; Acceptable tolerance for the root value. May be specified as 0.0 to cause the program to find the root as accurate as possible<p>
Output Zeroin returns an estimate for the root with accuracy 4*EPSILON*abs(x) + tol<p>
Algorithm<p>
G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical computations. M., Mir, 1980, p.180 of the Russian edition<p>
The function makes use of the bissection procedure combined with the linear or quadric inverse interpolation.<p>
At every step program operates on three abscissae - a, b, and c.<p>
b - the last and the best approximation to the root a - the last but one approximation c - the last but one or even earlier approximation than a that 1) |f(b)| &lt;= |f(c)| 2) f(b) and f(c) have opposite signs, i.e. b and c confine the root<p>
&lt; Distance from the last but one to the last approximation<p>
&lt; Actual tolerance<p>
&lt; Interpolation step is calculated in the form p/q; division<p>
&lt; operations is delayed until the last moment<p>
&lt; Step at this iteration     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="zeroin_8h-source.html">zeroin.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Mar 8 14:05:29 2005 for freesteam by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
